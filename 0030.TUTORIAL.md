# チュートリアル

## １．前提

- ```partyapp```の仮想環境を構築済
- ```partyapp```が連携するDBサーバを構築済である
- ```partyapp```の仮想環境がアクティベート済である

## ２．コーディングの準備

まずは、partyapp/requirements.txtを作成(実ファイルを参照のこと)

つづいて、```partyapp```で利用する外部パッケージのインストール。

```bash
cd ~/partyapp_workspace/partyapp
pip install -r requirements.txt
```

mysqlの接続情報を環境変数として設定する。  
接続時に自動設定されるように、```~/.bashrc```の最後尾に追記しておく。  
設定値は適宜自身の環境に合わせること。

また、sys.path.appendを全モジュールに書くのはあまり推奨できないとのことであったので、あらかじめ```partyapp_workspace```を、環境変数```PYTHONPATH```に追加しておく。

```bash
export DB_USER="username"
export DB_PASSWORD="password"
export DB_HOST="192.168.0.165"
export DB_PORT="3306"
export DB_NAME="partyapp"
export PYTHONPATH=$HOME/partyapp_workspace:$PYTHONPATH
```

接続時に読み込まれ、自動設定されるようになる。ただし、即時反映させたい場合は

```bash
source ~/.bashrc
```

## ４．パッケージとモジュールと__init__.pyについて

```モジュール```とは、pythonスクリプトが書かれたファイルのこと。  
外部モジュールからのオブジェクトのimportは、  
```from モジュール名 import オブジェクト名```  
の構文でimportする

モジュールが保存されているディレクトリのことを、```パッケージ```という。  
カレントディレクトリ配下にないパッケージへのパスは、環境変数```PYTHONPATH```、または、```sys.path```オブジェクトにパッケージのパスを追加しておく必要あり。  
Pythonインタープリタは、```PYTHONPATH```、または、```sys.path```にセットされたパスからモジュールを探す仕組となっているため。

上位パッケージのみが```PYTHONPATH```、または、```sys.path```オブジェクトにパッケージのパスとして追加されている場合は、以下のように上位パッケージから記述することでオブジェクトをimport可能。  
```from package0.package1.module import object```

この例のpackage1が```PYTHONPATH```、または、```sys.path```オブジェクトにパッケージのパスとして追加されていない場合は、  
```from package1 import object```  
と書いても```package1```をサーチできず、importに失敗する。

```partyapp```フォルダ配下の各フォルダにある```__init__.py```は、多くが空っぽのファイルになっている。  
これは、```python3.2```以前は、```__init__.py```ファイルが、フォルダをパッケージとして認識するための識別子として必須であったことの名残。  
```python3.3```以降は、```__init__.py```がなくても、pythonインタープリタはフォルダをパッケージとして認識してくれる。  
ただし、```__init__.py```があるフォルダはパッケージであると人が読んで認識しやすいので、可読性をあげるために不要でも慣例的に作成しているケースもあるとのこと。

## ３．SQLAlchemyのデータベースハンドラを生成するライブラリの作成

SQLAlchemyが```partyappdb```データベースを操作するためのデータベースハンドラを生成するライブラリ  
```partyapp/db/base.py```を作成。

## ４．データベースモデルの作成

### 4.1. enum型の定義ファイルを作成

列挙型データの型定義ファイル  
```partyapp/db/models/enums.py```を作成。

### 4.2. テーブルモデルを作成

各```メイン```テーブルのmodelを定義したモジュールを作成。

- ```partyapp/db/models/party.py```を作成。
- ```partyapp/db/models/category.py```を作成。
- ```partyapp/db/models/law.py```を作成。

各```アソシエーション```テーブルを1つのファイルにまとめて作成

- ```partyapp/db/models/associations.py```を作成。

なお、SQLAlchemyのモデルの概要については、```0040.MODEL.md```参照のこと。

### 4.3. テーブルモデルをまとめて読み込ませるパッケージ初期化ファイルの作成

アプリケーションからモデルをまとめてimportできるように、```partyapp/db/models```のパッケージファイルを作成

- ```partyapp/db/models/__init__.py```の作成

## ５．初期化コマンドなど、コマンド用スクリプトの作成

最初に、partyappdbにテーブルを作成したりするための操作を、コマンド化するためのファイルを作成しておく。  

- ```partyapp/cli.py```の作成

cli.pyの使い方
```partyapp```ディレクトリで、以下を実行。

```bash
# コマンド型式
# python -m partyapp.cli <コマンド関数名>
#
# 注意！！コマンド関数名の"_"(アンダースコア)は、"-"(ハイフン)に変換されるので要注意！！
# 関数connect_dbは、コマンドではconnect-dbとなる!!
#
#

python -m partyapp.cli connect-db

# ヘルプの表示
# コマンド型式
# python -m partyapp.cli <コマンド関数名> --help
python -m partyapp.cli connect-db --help

# コマンド一覧の表示
python -m partyapp.cli --help
```

ここに、テーブル一覧の表示とか、テーブルスキーマの表示とか、便利なコマンドを適宜追加していくと良い。

## ６．テーブルの作成

[上記](#５初期化コマンドなどコマンド用スクリプトの作成)で作成した```cli.py```の```init_db```コマンドを使って、```partyappdb```に空のテーブルを作成する。

 上記モデルファイルを配置

 main.py で一度 create_all 実行（開発初期のみ）

 Alembic を導入し以降は revision --autogenerate で差分管理

 seed_service.seed_categories() を実行して M_CATEGORY を初期化

 簡単なCRUDのサービス（例：user_service.py 相当）を Party/Law 用に1本ずつ作成

 tests/test_*.py でモデルの保存・リレーション解決・一意制約エラーなどを確認
