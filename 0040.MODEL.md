# SQLAlchemyのモデルについて

## １．SQLAlchemyのモデルとは

接続先データベースのテーブルごとに作成するクラスオブジェクトのこと。  
SQLAlchemyは、接続先データベースの各テーブルスキーマ(カラム、制約、リレーションなど)をテーブルごとに```class```で定義する。  
SQLAlchemyのモデルは、データベースに接続し、以下のことができる。

- モデルは CREATE の元定義として利用され、実際の作成は Base.metadata.create_all(engine) または Alembic で行う。
- モデルとして定義したテーブルのレコードの追加、編集、削除
- モデルとして定義したテーブルのレコードの検索
など

テーブル共通の属性やメソッドが定義されたBaseクラスを継承して作成。  
すなわち、SQLAlchemyでは、モデルを介して接続先データベースのデータ操作や検索を行う。

## ２．モデルの定義例

モデルは、テーブルごとに定義する。

以下、定義例

```python
# M_PARTYテーブルのモデル定義
from sqlalchemy import String, Date, CHAR
from sqlalchemy.orm import Mapped, mapped_column, relationship
from partyapp.db.base import Base
from datetime import date

class Party(Base):
    __tablename__ = "M_PARTY"

    id: Mapped[str] = mapped_column(CHAR(18), primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True, nullable=False, doc="政党名")
    short_name: Mapped[str | None] = mapped_column(String(50))
    founded_on: Mapped[date | None] = mapped_column(Date)
    dissolved_on: Mapped[date | None] = mapped_column(Date)

    law_roles: Mapped[list["PartyLawRole"]] = relationship(
        back_populates="party", cascade="all, delete-orphan"
    )
```

- モデルのクラス宣言  
  ```partyapp/db/base.py```で生成したデータベース接続ハンドラのBaseクラスを継承して定義

```python
class Party(Base):
```

- テーブル名のセット
  クラス変数__tablename__に、テーブル名をセットする

```python  
__tablename__ = "M_PARTY" 
```

- カラムの定義  
  カラムは、下記のように設定する
  - カラムは、モデルのクラス変数として定義
  - 型ヒントの型は、Mapped[<Python側のカラムの型>]で指定する
  - カラムのclass変数の初期値に、データベーステーブルのデータの型や制約を、mapped_columnの引数としてセットする
  
```python
id: Mapped[str] = mapped_column(CHAR(18), primary_key=True)
name: Mapped[str] = mapped_column(String(50), unique=True, nullable=False, doc="政党名")
short_name: Mapped[str | None] = mapped_column(String(50))
founded_on: Mapped[date | None] = mapped_column(Date)
dissolved_on: Mapped[date | None] = mapped_column(Date)
```

- リレーションの定義  
  他テーブルとのリレーションは、下記のように設定する
  - リレーションは、モデルのクラス変数として定義
  - 型ヒントの型は、Mapped[<リレーション先テーブルのモデルクラス名>]、またはMapped[list[<リレーション先テーブルのモデルクラス名>]]で指定する。  
  1:1のリレーションの場合は、Mapped[<リレーション先テーブルのモデルクラス名>]  
  1:多(リレーション先)の場合は、Mapped[list[<リレーション先テーブルのモデルクラス名>]]
  - リレーションのclass変数の初期値に、リレーション先モデルのリレーションのclass変数名(ここでは、```party```)をrelationshipの引数``` back_populates```にセットする。
  - 1:多(リレーション先)の場合は、relationship の引数 cascade を設定すると、親オブジェクトの削除・追加などの操作がセッション経由で子オブジェクトにも自動反映される。  
  設定は必須ではないが、一般的には設定する。  
  ```all, delete-orphan```は、該当する元のレコードを削除した場合に、リレーション先の外部キーを持つレコードも削除される設定。
  - 1:多(リレーション先)のリレーションで親テーブルとして```relationship```に```cascade```をセットした場合、子側のテーブルでは、親テーブルの```primary key```、または```UNIQUE```制約のある列を```foreign key```としてもつ必要がある  
  (下記の```PartyLawRole```モデルのコード参照のこと)

```python
law_roles: Mapped[list["PartyLawRole"]] = relationship(
    back_populates="party", cascade="all, delete-orphan"
)
```

参考までに、リレーション先の```PartyLawRole```モデルの定義は、以下のようになっている。  
```PartyLawRole```モデルの方へも、```Party```モデルへのリレーションがクラス変数```party```としてセットされている。

```python
class PartyLawRole(Base):
    __tablename__ = "T_PARTY_LAW_ROLE"

    law_id: Mapped[str] = mapped_column(CHAR(18), ForeignKey("T_LAW.id"), primary_key=True)
    party_id: Mapped[str] = mapped_column(CHAR(18), ForeignKey("M_PARTY.id"), primary_key=True)
    role: Mapped[PartyRole] = mapped_column(
        SAEnum(PartyRole, native_enum=False, validate_strings=True), primary_key=True
    )
    note: Mapped[str | None]

    law: Mapped["Law"] = relationship(back_populates="party_roles")
    party: Mapped["Party"] = relationship(back_populates="law_roles")

    __table_args__ = (
        Index("ix_plr_party_id", "party_id"),
        Index("ix_plr_role", "role"),
    )
```

以下、```PartyLawRole```モデルの補足追加。```Party```モデルで説明していないもの限定

- ForeignKeyの設定
  他テーブルのカラムの外部キーとなっているカラムは、```mapped_column```の中で```ForeignKey("<dbのテーブル名>.<dbのカラム名>")```の形式で指定する。  
  親テーブル側のモデルにリレーションがなくても外部キーは有効。ただし双方向アクセスや cascade を利用する場合には、親側にも relationship を定義する。  
  このとき、親テーブル側のモデル定義で cascade="all, delete-orphan" を設定すると、親削除時に子レコードも削除される（設定は必須ではない）。
- enum制約の設定  
  カラム定義のclass変数において、```mapped_column```の引数として```SAEnum```に必要な引数をセットすることで指定する。  
  - ```native_enum=False```に設定すると、DB側は単なる文字列として保存される。  
  下記の```validate_strings=True```とセットすることで、enum制約の制御は、Python側でのみ行うようにできる。
  Trueにセットするとデータベース側でのenum制御となり、処理が効率化される一方、rdbmsごとに方言があるため、データベースサーバの種類によって動作が変わることがあるとのこと。
  - ```validate_strings=True```(デフォルトはFalse)にセットすると、DBに送信する前に、Python側でenumのチェックをする。  
  ```native_enum=False```にセットすると、DB 側は文字列カラムになる。Enum メンバーを渡した場合は自動でシリアライズされるが、文字列を直接渡す場合は validate_strings=True を付けないと不正値も通ってしまう。  
- Indexの設定  
  Indexを管理したい場合は、モデル定義で変数```__table_args__```に```Index("<インデックス名>", "<カラム名>"), ...```の形式でセットする。  
  Index名を明示的に指定することで、後から管理しやすくなる。  
  設定しない場合は、SQLAlchemy が命名規則に従って自動でIndex名を付与する。
